# Online Code Runner

Интерактивный онлайн-редактор кода с серверным выполнением в изолированных Docker-контейнерах.

Пользователь пишет код в браузере (JS / Python / C++ / Java), нажимает **Run**, код уезжает на сервер, там в отдельном окружении компилируется/исполняется, результат и ошибки возвращаются в интерфейс.  
Ввод с клавиатуры (`stdin`, например `input()` в Python) поддерживается.  
Текущие версии кода сохраняются в локальной истории, которую можно просматривать, копировать и восстанавливать в редактор. 

---

## Основные возможности

- Выполнение кода в **отдельном окружении** для каждого запуска:
  - запуск в отдельном Docker-контейнере `runner` (через backend);
  - ограничение по ресурсам (память, CPU, количество процессов);
  - окружение очищается после завершения выполнения.
- Поддерживаемые языки:
  - **JavaScript** (Node.js)
  - **Python 3**
  - **C++ (G++ / C++17)**
  - **Java 17**
- Поддержка **stdin**:
  - отдельное текстовое поле **Input (stdin)**;
  - ввод прокидывается в процесс через STDIN;
  - работает с `input()` в Python, `std::cin` в C++, `Scanner` в Java и т.п.
- WebSocket-API:
  - фронтенд общается с backend по WebSocket;
  - протокол: JSON `{ language, code, stdin }`;
  - возможно подключение внешних клиентов (не только встроенного UI).
- Современный фронтенд:
  - Next.js + React;
  - редактор кода на базе CodeMirror с подсветкой синтаксиса для всех языков;
  - трёхколоночный интерфейс с изменяемой шириной колонок:
    - левая колонка — редактор кода;
    - средняя колонка — `Input (stdin)` и `Output` с вертикальным разделителем;
    - правая колонка — история версий кода.
- История версий кода:
  - автоматическое сохранение снимка кода при каждом запуске (**Run**) и начальной загрузке;
  - хранение в `localStorage` браузера (данные не уходят на сервер);
  - каждая версия содержит дату/время и язык программирования;
  - разворачиваемые карточки с подсветкой синтаксиса и кнопками:
    - **Копировать**;
    - **Вставить в редактор** (заменяет текущий код на выбранную версию).
  - пагинация по 5 версий на страницу с компактной навигацией (… при большом числе страниц).
- Скачивание кода:
  - кнопка **Save** в заголовке редактора;
  - выгрузка текущего кода в файл с корректным расширением (`.js`, `.py`, `.cpp`, `.java`).

---

## Стек

- **Frontend**
  - Next.js
  - React
  - TypeScript
  - CodeMirror (`@uiw/react-codemirror`)
  - Тема `@uiw/codemirror-theme-atomone`

- **Backend**
  - Node.js
  - TypeScript
  - `ws` (WebSocket-сервер)
  - Запуск кода через внешние процессы в изолированной среде (контейнер runner)

- **Инфраструктура**
  - Docker / Docker Compose
  - Отдельный `runner`-образ с установленными:
    - Node.js
    - Python 3
    - G++ (C++17)
    - OpenJDK 17

---

## Архитектура

Система состоит из трёх сервисов, описанных в `docker-compose.yml`:

- **`web`**  
  Next.js фронтенд:
  - отдаёт UI;
  - устанавливает WebSocket-подключение к `api`.

- **`api`**  
  WebSocket-сервер:
  - принимает JSON `{ language, code, stdin }`;
  - формирует задачу на выполнение кода;
  - создаёт временный рабочий каталог;
  - пишет туда исходник (`main.js`, `main.py`, `main.cpp`, `Main.java`);
  - запускает выполнение кода в изолированном окружении (контейнер `runner` / внешний процесс);
  - собирает `stdout` / `stderr` и отправляет обратно по WebSocket.

- **`runner`**  
  Образ, внутри которого непосредственно выполняется код:
  - содержит все необходимые интерпретаторы и компиляторы;
  - используется backend-сервисом для безопасного запуска пользовательского кода.

Хранилище временных файлов обычно оформлено отдельным volume, общий для `api` и `runner`, чтобы можно было легко обмениваться исходниками и артефактами выполнения.

---

## Интерфейс и компоненты фронтенда

Фронтенд реализован на Next.js (App Router) и построен вокруг редактора кода.

### Основные элементы UI

- **Трёхколоночный макет (desktop):**
  - **Левая колонка** – редактор кода (CodeMirror).
  - **Средняя колонка** – блоки:
    - `Input (stdin)` — поле ввода стандартного ввода;
    - `Output` — вывод программы;
    - между ними — горизонтальный разделитель, позволяющий изменять высоту блоков.
  - **Правая колонка** – история версий кода.
  - Между колонками — вертикальные разделители, позволяющие менять ширину:
    - между редактором и блоком `stdin/output`;
    - между `stdin/output` и историей.

- **Адаптивность:**
  - на широких экранах отображаются три колонки;
  - при уменьшении ширины экрана колонки последовательно «складываются» в вертикальный стек, разделители скрываются, макет остаётся удобочитаемым.

### Логика компонентов

- **`CodeEditor`**  
  Корневой компонент редактора:
  - инициализирует состояние через `useReducer` (`language`, `codeContent`, `inputContent`, `outputContent`);
  - предоставляет состояние и функции изменения через контексты `StateContext` и `DispatchContext`;
  - управляет размерами колонок и разделителями;
  - содержит историю версий кода (массив снимков).

- **Редуктор и контексты (`reducer.ts`, `contexts.ts`)**  
  - описывают все возможные изменения состояния: смена языка, обновление кода, stdin, вывода;
  - позволяют дочерним компонентам работать с состоянием без «прокидывания» пропсов.

- **`CodeField`**  
  Редактор кода:
  - использует `@uiw/react-codemirror` с подсветкой для:
    - JavaScript (`@codemirror/lang-javascript`);
    - Python (`@codemirror/lang-python`);
    - C++ (`@codemirror/lang-cpp`);
    - Java (`@codemirror/lang-java`);
  - тема оформления – `atomone`;
  - при изменении текста отправляет экшен `setCodeContent` в редуктор.

- **`CodeFieldHeader`**  
  Панель управления над редактором:
  - селект выбора языка;
  - кнопка **Save**:
    - формирует `Blob` из текущего кода;
    - скачивает файл `code.<расширение>` (`.js`, `.py`, `.cpp`, `.java`);
  - кнопка **Run**:
    - вызывает `executor(language, codeContent, inputContent)`;
    - по результату обновляет `outputContent`;
    - триггерит сохранение текущей версии кода в историю.

- **`InputField`**  
  Контролируемое поле ввода stdin:
  - каждое изменение сразу попадает в `state.inputContent`;
  - значение передаётся на backend в поле `stdin`.

- **`ContentField`**  
  Универсальная карточка с заголовком и содержимым:
  - используется для блоков `Code`, `Input (stdin)`, `Output` и `History`.

- **`HistorySection`**  
  Компонент истории версий кода:
  - принимает массив снимков и callback для вставки версии в редактор;
  - реализует:
    - вывод по 5 версий кода на страницу;
    - пагинацию с компактным отображением страниц (`…` при большом числе страниц);
    - разворачиваемые карточки с:
      - датой и временем сохранения;
      - языком (`js`, `python`, `cpp`, `java`);
      - подсвеченным блоком кода (CodeMirror, только чтение);
      - кнопками «Копировать» и «Вставить в редактор».

- **Сохранение истории**  
  - история хранится в `localStorage` под отдельным ключом;
  - загружается при инициализации приложения;
  - лимитируется по количеству (например, до 50 последних записей);
  - не передаётся на сервер.

---

## Запуск через Docker Compose

### Требования

- Установлены:
  - Docker
  - Docker Compose (входит в Docker Desktop на Windows/macOS)

### Шаги

1. Клонировать репозиторий:

   ```bash
   git clone <url_репозитория>
   cd <папка_репозитория>
   ```

2. Собрать образы:

   ```bash
   docker compose build
   ```

3. Запустить стек:

   ```bash
   docker compose up -d
   ```

4. Открыть фронтенд:

   ```text
   http://localhost:3000
   ```

Backend (WebSocket-сервер) доступен по адресу:

```text
ws://localhost:8080
```

---

## Использование

1. Открыть UI (`http://localhost:3000`).
2. В верхнем селекте выбрать язык:
   - JavaScript
   - Python
   - C++
   - Java
3. Написать код в редакторе **Code**.
4. При необходимости ввести данные для `stdin` в поле **Input (stdin)**.
5. Нажать **Run**:
   - код отправится на backend по WebSocket;
   - сервер выполнит его в изолированном окружении;
   - результат появится в блоке **Output**.
6. Нажать **Save**, чтобы скачать текущий код в файл соответствующего языка.
7. Перейти в правую колонку **History**, чтобы:
   - посмотреть предыдущие версии кода;
   - развернуть карточку версии и изучить её с подсветкой;
   - скопировать или вставить выбранную версию обратно в редактор.

---

## Формат WebSocket-протокола

Фронтенд отправляет на backend JSON следующего вида:

```json
{
  "language": "python",
  "code": "s = input()\nprint('echo:', s)",
  "stdin": "hello stdin\n"
}
```

Поля:

- `language` – строковый идентификатор языка:
  - `"js"` / `"javascript"`
  - `"py"` / `"python"`
  - `"cpp"` / `"cplusplus"`
  - `"java"`
- `code` – исходный код для выполнения;
- `stdin` – опциональная строка, которая будет отправлена в STDIN процесса  
  (может содержать несколько строк, разделённых `\n`).

**Ответ сервера**:

- текстовая строка, содержащая объединённые `stdout` и `stderr` программы;
- при ошибке формата запроса — строка `"Invalid payload"`.

---

## Реализация запуска кода

Server-side логика выполнения кода:

1. Создаётся временная директория (например, `/workspace/run-XXXX`).
2. В неё сохраняется исходный файл:
   - JS: `main.js`
   - Python: `main.py`
   - C++: `main.cpp`
   - Java: `Main.java`
3. Внутри окружения запускается команда для соответствующего языка:

   - JavaScript: `node main.js`
   - Python: `python3 main.py`
   - C++: `g++ main.cpp -O2 -std=c++17 -o main && ./main`
   - Java: `javac Main.java && java Main`

4. Ввод (`stdin`) передаётся в процесс, вывод (`stdout` + `stderr`) накапливается.
5. После завершения выполнения:
   - временная директория очищается;
   - окружение (контейнер / процесс) уничтожается.

---

## Переменные окружения

### Backend (`api`)

- `PORT` – порт WebSocket-сервера (по умолчанию `8080`);
- `HOST` – хост (по умолчанию `0.0.0.0`);
- дополнительные переменные могут задавать пути к рабочим директориям и volume’ам.

### Frontend (`web`)

- `NEXT_PUBLIC_WS_URL` – URL WebSocket-сервера, видимый из браузера  
  (по умолчанию `ws://localhost:8080`; в Docker-сетке обычно `ws://api:8080`).

---

## Безопасность и ограничения

- Код выполняется в **изолированном окружении** (контейнер runner / отдельный процесс):
  - ограничение по памяти;
  - ограничение по CPU;
  - ограничение по количеству процессов.
- Сеть по умолчанию отключена либо ограничена.
- Временные файлы создаются в отдельной директории и удаляются после завершения.

Для учебного/демонстрационного режима этих мер достаточно. Для продакшена по необходимости можно добавить:

- таймауты по времени выполнения;
- отдельный пул worker-нод для запуска пользовательского кода;
- дополнительную валидацию и фильтрацию входящих задач.

---

## Структура репозитория

```text
.
├── backend/                  # WebSocket API (Node.js + TypeScript)
│   ├── src/
│   │   ├── server.ts         # WebSocket-сервер
│   │   └── lib/executor/     # Логика запуска кода
│   └── Dockerfile
├── frontend/                 # Next.js фронтенд с редактором кода
│   ├── app/
│   │   ├── page.tsx          # Главная страница, монтирует CodeEditor
│   │   └── layout.tsx        # Общий макет приложения
│   ├── components/
│   │   └── CodeEditor/
│   │       ├── CodeEditor.tsx        # Корневой компонент редактора
│   │       ├── reducer.ts            # Редьюсер состояния
│   │       ├── contexts.ts           # Контексты состояния и dispatch
│   │       ├── CodeField/            # Компонент редактора кода (CodeMirror)
│   │       ├── CodeFieldHeader/      # Заголовок: язык, Run/Save
│   │       └── HistorySection/       # История версий кода с пагинацией
│   ├── ui/
│   │   ├── Button/                   # Базовая кнопка
│   │   ├── ContentField/             # Обёртка-карточка с заголовком
│   │   ├── InputField/               # Поле ввода stdin
│   │   └── RunButton/                # Анимированная кнопка запуска
│   └── Dockerfile
├── runner/                   # Docker-образ с рантаймами (Node, Python, G++, Java)
├── docker-compose.yml
└── README.md                 # этот файл
```
